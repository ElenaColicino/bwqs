% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bwqs_main-revised.R
\name{bwqs}
\alias{bwqs}
\title{Fitting Bayesian Weighted Quantile Sum regression models}
\usage{
bwqs(
  formula,
  mix_name,
  data,
  q,
  Dalp = NULL,
  chains = 1,
  iter = 10000,
  thin = 3,
  seed = 2019,
  start_value = NULL,
  c_int = c(0.025, 0.975),
  family = "gaussian",
  prior = "None"
)
}
\arguments{
\item{formula}{Object of class \code{formula} specifying the relationship between the outcome and the
covariates of the model not involved in the mixture variable. If the model has no covariates specify
\code{y ~ NULL}.}

\item{mix_name}{A character vector listing the variables contributing to a mixture effect.}

\item{data}{The \code{data.frame} containing the variables (covariates and elements of the mixture)
to be included in the model.}

\item{q}{An \code{integer} to specify how mixture variables will be ranked, e.g. in quartiles
(\code{q = 4}), deciles (\code{q = 10}), or percentiles (\code{q = 100}). If \code{q = NULL} then
the values of the mixture variables are taken (these must be standardized or the domain must be the same).}

\item{Dalp}{A \code{vector} containing the parameters of the Dirichlet distribution of the weights, the number
of the elements of the vector has to be equal to the number of chemicals. If \code{Dalp = NULL}
the domain is explored uniformly.}

\item{chains}{An \code{integer} to specify the number of chain in Hamiltonian Monte Carlo algorithm.
Default value \code{chains = 1}.}

\item{iter}{An \code{integer} to specify the lenght of chain in Hamiltonian Monte Carlo algorithm.
Default value \code{iter = 10000}.}

\item{thin}{An \code{integer} to specify the thinning parameter in Hamiltonian Monte Carlo algorithm.}

\item{seed}{An \code{integer} value to fix the seed. If \code{seed = NULL} the seed are randomly choosen.}

\item{start_value}{A \code{vector} containing the initial value of the prior distribution,
if it is equal to NULL random values are chosen.}

\item{c_int}{A \code{vector} of two elements to specify the credible intervals for parameters, for 95% credible
interval \code{c_int = c(0.025,0.975)} (default).}

\item{family}{A \code{string} to specify the type of outcome. Possible values are "gaussian" (default),
"binomial" and "poisson".}

\item{prior}{A \code{string} to specify the direction of prior distribution. Possible values are 
"None"(default), "positive" and "negative".}
}
\value{
\code{bwqs} returns a list with two argument:
\item{fit}{An \code{S4} object with all details of the Hamiltonian Monte Carlo, all the extractions
from the posterior distribution and all values of the parameters}
\item{summary_fit}{Table with the statistics of the parameters: mean, standard error of the mean,
standard deviation, lower and upper values for the credible interval (with credible level specified
by \code{c_int}), n_eff and Rhat. For further details see https://cran.r-project.org/web/packages/rstan/rstan.pdf}
}
\description{
Fits Bayesian Weighted Quantile Sum (BWQS) regressions for continuous and binomial outcomes. This model
provides estimation for the mixture composition and overall effect of the mixture on the outcomes using
bayesian framework.
}
\details{
The function \code{bwqs} uses the package \code{rstan} which allows the connection with STAN,
a specific software, written in C++ for bayesian inference, for further information see https://mc-stan.org/.
}
\examples{
#load libraries
library(MASS)
library(BWQS)

# fix the seed
set.seed(1234)

# Sample sizes
N <- 1000

# Mean & SD of variables
mu <- c(0,0,0,1,3)
sd <- c(1,1,1,3,1)
sd2 <- sd \%*\% t(sd)

# Correlation Matrix
rho <- 0.65
corMat <- cbind(c(1,rho,rho^2,rho^2,rho^2),
                c(rho,1,rho^2, rho^2, rho^2),
                c(rho^2,rho^2,1,rho^2,rho^2),
                c(rho^2,rho^2,rho^2,1, rho),
                c(rho^2,rho^2,rho^2,rho,1))

# Covariance Matrix
Sigma <- sd2*corMat

# Simulating three correlated exposure variables
X <- as.data.frame(mvrnorm(N, mu=mu, Sigma = Sigma, empirical=TRUE))
colnames(X)<-c("X1","X2","X3","X4","X5")

# Quantile extraction
Xq <- as.matrix(quantile_split(X, mix_name = colnames(X), q=4))

# Intercept coefficient
beta0 <- 2

# Overall effect
beta1 <- 0.8

# Weights
W <- c(0.5,0.20,0.2,0.05,0.05)

# sigma of the model
sigma <- 1

# Outcome simulation (continuos)
y <- rnorm(N, beta0 + beta1*(Xq \%*\% W), sd = sigma)

# Aggregate data in a data.frame
Data <-as.data.frame(cbind(y,X))

fit_bwqs <- bwqs(y ~ NULL, mix_name = c("X1","X2","X3","X4","X5"),
                 data = Data, q=4, c_int = c(0.1,0.9), seed = NULL)
fit_bwqs$summary_fit

# Plots of weights and parameters
bwqs_plot(fit_bwqs, parms = "W", size = 2)
bwqs_plot(fit_bwqs, parms = c("beta0","beta1","sigma"), size = 2)

# WAIC
bwqs_waic(fit_bwqs$fit)

# Traceplot and autocorrelation plot
stan_trace(fit_bwqs$fit, pars = c("beta0","beta1","W","sigma"))
stan_ac(fit_bwqs$fit, pars = c("beta0","beta1","W","sigma"))

}
\author{
Nicolo Foppa Pedretti, Elena Colicino
}
